d$y <- valueFunction(d$x, 1, subjectProfile)
d
.3*.9
.3*1.1
.3*2
1/.3
.3*3.33333
1/.5
.5*2
x <- seq(0,1,.001)
length(x)
y <- ((x * -1) + (1/.3) + 1) / (1/.3)
1/.3
min(y)
max(y)
y <- x * -1
min(y)
max(y)
y <- y + 1
y <- y + (1/.3)
max(y)
1/.3
.3/(1+.3)
1/.3
d <- data.frame(x = seq(0,1,.01))
d
d$y <- -d$x
range(d$y)
d$y <- d$y + (1/.3)
range(d$y)
d$y <- d$y * (seq(1,max(d$y), length.out = length(d$y)) / d$y)
range(d$y)
plot(d$x, d$y)
.3*3.33333
1/.9
.111 * (1/.111)
d$y <- d$x * -1
plot(d$x, d$y)
d$y <- d$y + (1/.3)
plot(d$x, d$y)
d$y <- d$y * (seq(1, max(d$y), length.out = length(d$y)) / d$y)
plot(d$x, d$y)
d$y <- -d$x
d$y <- d$y + (1/.3)
plot(d$x, d$y)
d$y <- d$y * (seq(max(d$y), 1, length.out = length(d$y)) / d$y)
plot(d$x, d$y)
d <- data.frame(x = seq(0,1,.01))
(-d$x + (1/.3)) * ((seq(1/.3, 1, length(d$x))/d$x))
d$y <- (-d$x + (1/.3)) * ((seq(1/.3, 1, length(d$x))/d$x))
d$y <- (-d$x + (1/.3)) * ((seq(1/.3, 1, length.out = length(d$x))/d$x))
plot(d$x, d$y)
d$y <- (-d$x + (1/.3))
plot(d$x, d$y)
d$y <- d$y * (seq(1/.3, 1, length.out = length(d$x)) / d$y)
plot(d$x, d$y)
d$x
help
help(which)
d$x
which(0.74 %in% d$x)
which(d$x %in% .74)
d$x[75]
convertBias(bias, exponentsFixed) {
biasVector <- seq(0,1,.01)
biasIndex <- which(biasVector %in% bias)
out <- -bias * (1/exponentsFixed)
out <- out * (seq(1/exponentsFixed, 1, length.out = biasVector)[biasIndex] / out)
return(out)
}
convertBias(bias, exponentsFixed) {
biasVector <- seq(0,1,.01)
biasIndex <- which(biasVector %in% bias)
out <- -bias * (1/exponentsFixed)
out <- out * (seq(1/exponentsFixed, 1, length.out = length(biasVector))[biasIndex] / out)
return(out)
}
convertBias <- function(bias, exponentsFixed) {
biasVector <- seq(0,1,.01)
biasIndex <- which(biasVector %in% bias)
out <- -bias * (1/exponentsFixed)
out <- out * (seq(1/exponentsFixed, 1, length.out = length(biasVector))[biasIndex] / out)
return(out)
}
convertBias(.5,.3)
d$y <- convertBias(d$x, .3)
plot(d$x, d$y)
convertBias <- function(bias, exponentsFixed) {
## This got super complicated but i'm pretty confident it works
## Check in the sketch book to see the crazy linear algebra
## Essentially, bias is theoretically sampled from a 0:1 parameter space, where 0 kills the effect and 1 gives it max strength
## I need to convert this bias to a new vector space with range (1/exponentsFixed):1 where (1/exponentsFixed) kills the effect and 1 gives it max strength
## note that (1/exponentsFixed):1 is actually max:min, thus the relationship between the theoretical new vector and the old one is r = -1
## validate this function with the plotting function below
biasVector <- seq(0,1,.01)
biasIndex <- which(biasVector %in% bias)
out <- -bias * (1/exponentsFixed)
out <- out * (seq(1/exponentsFixed, 1, length.out = length(biasVector))[biasIndex] / out)
return(out)
}
validateConvertBias <- function(bias, exponentsFixed) {
d <- data.frame(x = seq(0,1,.01))
d$y <- convertBias(d$x, 0.3) ## 0.3 arbitrarily chosen
plot(d$x, d$y)
}
validateConvertBias <- function() {
d <- data.frame(x = seq(0,1,.01))
d$y <- convertBias(d$x, 0.3) ## 0.3 arbitrarily chosen
plot(d$x, d$y)
}
validateConvertBias()
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * bias + subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity > 0, relativeIntensity^exponentsFinal, -lossAversionFinal * (-relativeIntensity) ^ exponentsFinal)
return(out)
}
d <- data.frame(x = seq(-.5,.5, .01))
d$y <- valueFunction(seq(0, 1, length.out = d$x), 1, subjectProfile)
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 1, subjectProfile)
plot(d$x, d$y)
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 0, subjectProfile)
plot(d$x, d$y)
d
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 0.1, subjectProfile)
d
plot(d$x, d$y)
## RANDOM EFFECTS
## keeping these pretty tight for now
interceptRandom <- abs(toLogOdds(.1))
exponentsRandom <- .2
lossAversionRandom <- .2
subjectProfile <- buildSubjectProfile
subjectProfile <- buildSubjectProfile()
buildSubjectProfile <- function() {
## Returns a vector with values to be added to / subtracted from fixed effects for each subject
subjectProfile <- c(subjectIntercept = rnorm(1, 0, interceptRandom), subjectExponents = rnorm(1, 0, exponentsRandom), subjectLossAversion = rnorm(1, 0, lossAversionRandom))
return(subjectProfile)
}
subjectProfile <- buildSubjectProfile()
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 0.1, subjectProfile)
plot(d$x, d$y)
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * bias #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity > 0, relativeIntensity^exponentsFinal, -lossAversionFinal * (-relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 0.1, subjectProfile)
plot(d$x, d$y)
d$y <- valueFunction(seq(0, 1, length.out = length(d$x)), 0.001, subjectProfile)
plot(d$x, d$y)
d$y <- valueFunction(d$x + 0.5, 0.001, subjectProfile)
plot(d$x, d$y)
exponentsFixed
convertBias(.001, exponentsFixed = )
convertBias(.001, exponentsFixed)
convertBias <- function(bias, exponentsFixed) {
## This got super complicated but i'm pretty confident it works
## Check in the sketch book to see the crazy linear algebra
## Essentially, bias is theoretically sampled from a 0:1 parameter space, where 0 kills the effect and 1 gives it max strength
## I need to convert this bias to a new vector space with range (1/exponentsFixed):1 where (1/exponentsFixed) kills the effect and 1 gives it max strength
## note that (1/exponentsFixed):1 is actually max:min, thus the relationship between the theoretical new vector and the old one is r = -1
## validate this function with the plotting function below
biasVector <- seq(0,1,.001)
biasIndex <- which(biasVector %in% bias)
out <- -bias * (1/exponentsFixed)
out <- out * (seq(1/exponentsFixed, 1, length.out = length(biasVector))[biasIndex] / out)
return(out)
}
convertBias(.001, exponentsFixed)
d$y <- valueFunction(d$x + 0.5, 0.001, subjectProfile)
plot(d$x, d$y)
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity > 0, relativeIntensity^exponentsFinal, -lossAversionFinal * (-relativeIntensity) ^ exponentsFinal)
return(out)
}
convertBias
validateConvertBias()
validateConvertBias
valueFunction
decision
buildSubjectProfile
ls()
d
function() {
## Returns a vector with values to be added to / subtracted from fixed effects for each subject
subjectProfile <- c(subjectIntercept = rnorm(1, 0, interceptRandom), subjectExponents = rnorm(1, 0, exponentsRandom), subjectLossAversion = rnorm(1, 0, lossAversionRandom))
return(subjectProfile)
}
d$y <- valueFunction(d$x + .5, .001, subjectProfile)
plot(d$x, d$y)
d$y <- valueFunction(d$x + .5, 0, subjectProfile)
d
convertBias(0,.5)
biasVector <- seq(0,1,.001)
bias <- 0
biasIndex <- which(biasVector %in% bias)
biasIndex
validateConvertBias <- function() {
d <- data.frame(x = seq(0,1,.01))
d$y <- convertBias(d$x, 0.3) ## 0.3 arbitrarily chosen
plot(d$x, d$y)
}
validateConvertBias <- function() {
d <- data.frame(x = seq(0,1,.01))
d$y <- convertBias(d$x, 0.3) ## 0.3 arbitrarily chosen
plot(d$x, d$y)
}
validateConvertBias()
convertBias <- function(bias, factorFixed) {
## This got super complicated but i'm pretty confident it works
## Check in the sketch book to see the crazy linear algebra
## Essentially, bias is theoretically sampled from a 0:1 parameter space, where 0 kills the effect and 1 gives it max strength
## I need to convert this bias to a new vector space with range (1/exponentsFixed):1 where (1/exponentsFixed) kills the effect and 1 gives it max strength
## note that (1/exponentsFixed):1 is actually max:min, thus the relationship between the theoretical new vector and the old one is r = -1
## validate this function with the plotting function below
biasVector <- seq(0,1,.001)
biasIndex <- which(biasVector %in% bias)
out <- -bias + (1/factorFixed)
out <- out * (seq(1/factorFixed, 1, length.out = length(biasVector))[biasIndex] / out)
return(out)
}
validateConvertBias()
convertBias(0,.5)
d$y <- valueFunction(d$x + 0.5, 0, subjectProfile)
plot(d$x, d$y)
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
-.5^.5
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity < 0, relativeIntensity^exponentsFinal, -lossAversionFinal * (-relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
d
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity > 0, relativeIntensity^exponentsFinal, -lossAversionFinal * (-relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity < 0, (-relativeIntensity)^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity < 0, -relativeIntensity^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity < 0, relativeIntensity^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
-.5^.3
range(d$x)
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
exponentsFinal
bias
bias <- 1
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
exponentsFinal
-.3^0.3
d
relativeIntensity
relativeIntensity <- -.4
exponentsFinal
## compute value
out <- ifelse(relativeIntensity < 0, relativeIntensity^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
out
relativeIntensity^exponentsFinal
relativeIntensity
exponentsFinal
-0.4^0.3
(relativeIntensity) ^ exponentsFinal
exponentsFinal
(relativeIntensity)
(-0.4)^0.3
(--0.4)^0.3
-(--0.4)^0.3
(-relativeIntensity) ^ exponentsFinal
-(-relativeIntensity) ^ exponentsFinal
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed),0),1)# + subjectProfile['subjectExponents'], 0), 1)
lossAversionFinal <- lossAversionFixed * convertBias(bias, lossAversionFixed) #+ subjectProfile['subjectLossAversion']
## compute value
out <- ifelse(relativeIntensity < 0, -(-relativeIntensity)^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
return(out)
}
d$y <- valueFunction(d$x + 0.5, 1, subjectProfile)
plot(d$x, d$y)
abs(d[d$x==0.2,]$y)*2 == d[d$x == -0.2,]$y
abs(d[d$x==0.2,]$y)*2 == abs(d[d$x == -0.2,]$y)
abs(d[d$x==0.2,]$y)*2
abs(d[d$x==0.2,]$y)
d[d$x==0.2,]$y
d
d[d$x == 0.2,]
d[d$x == 0.35,]
d[d$x == 0.20,]
x[71,]
d[71,]
d[71,]$x
d[d$x==.2,]
d[d$x==-.35,]
abs(d[d$x == .35,]$y) == d[d$x == .35,]$y * 2
c(abs(d[d$x == .35,]$y), d[d$x == .35,]$y * 2)
c(abs(d[d$x == -.35,]$y), d[d$x == .35,]$y * 2)
c(abs(d[d$x == -.35,]$y * 2), d[d$x == .35,]$y )
abs(d[d$x == -.35,]$y * 2) == d[d$x == .35,]$y
d$y <- decision(d$x + 0.5, 1, 100,100, subjectProfile)
plot(d$x, d$y)
d
d[d$x == .2,]
d[d$x > .19 & d$x < .21,]
d[d$x > .19999999 & d$x < .2099999,]
seq(-.5,.5,01)
seq(-.5,.5,.01)
d$x <- seq(-.5,.5,.01)
d[d$x == .2,]
d
d[d$x == .25,]
d[d$x == .26,]
d[d$x == .27,]
d[d$x == .28,]
d[d$x == .22,]
d[d$x == .15,]
d[d$x == .10,]
d$x
d[d$x == .01,]
seq(-.5,.5,.01)
x <- seq(-.5,.5,.01)
x[x == .2]
d
he <- d[96,'y']
he
hm <- d[76, 'y']
em <- d[26, 'y']
ee <- d[6, 'y']
c <- data.frame(he = he, hm = hm, ee = ee, em = em)
c
c <- c %>%
gather(condition, refSelection, he:em)
c
c$difficulty <- c(rep('Harder than Reference', 2), rep('Easier than Reference', 2))
c$difference <- rep(c('Extreme', 'Moderate'), 2)
c
c %>%
ggplot(aes(x = difficulty, y = refSelection, group = difference)) +
geom_bar(stat = 'identity', aes(fill = difference), position = position_dodge(width = .9))
c %>%
ggplot(aes(x = difficulty, y = refSelection, group = difference)) +
geom_bar(stat = 'identity', aes(fill = difference), position = position_dodge(width = .9)) +
ylim(0,1)
plot(d$x, d$y)
d
decision <- function(criticalDeckIntensity, bias, trial, trialMax, subjectProfile) {
## takes as input all this stuff above
## returns the probability of choosing the reference deck
## within-subject noise
noiseSd <- 0
## Level 1 equation
proba <-  valueFunction(criticalDeckIntensity, bias, subjectProfile) * (trial / trialMax) + rnorm(1, 0, noiseSd) #subjectProfile['subjectIntercept'] +
proba <- exp(proba) / (1 + exp(proba))
return(proba)
}
d$y <- decision(d$x + 0.5, 1, 100,100, subjectProfile)
plot(d$x, d$y)
d
he <- d[96,'y']
hm <- d[76, 'y']
em <- d[26, 'y']
ee <- d[6, 'y']
c <- data.frame(he = he, hm = hm, ee = ee, em = em)
c <- c %>%
gather(condition, refSelection, he:em)
c
c$difficulty <- c(rep('Harder than Reference', 2), rep('Easier than Reference', 2))
c$difference <- rep(c('Extreme', 'Moderate'), 2)
c %>%
ggplot(aes(x = difficulty, y = refSelection, group = difference)) +
geom_bar(stat = 'identity', aes(fill = difference), position = position_dodge(width = .9)) +
ylim(0,1)
c
difference
c$difference
factor(c$difference)
c$difference <- factor(c$difference, levels = levels(factor(c$difference))[2,1])
c$difference <- factor(c$difference, levels = levels(factor(c$difference))c(2,1))
c$difference <- factor(c$difference, levels = levels(factor(c$difference))[c(2,1)])
factor(c$difference)
c %>%
ggplot(aes(x = difficulty, y = refSelection, group = difference)) +
geom_bar(stat = 'identity', aes(fill = difference), position = position_dodge(width = .9)) +
ylim(0,1)
## RANDOM EFFECTS
## keeping these pretty tight for now
# interceptRandom <- abs(toLogOdds(.1))
# exponentsRandom <- .2
# lossAversionRandom <- 1
interceptRandom <- 0
exponentsRandom <- 0
lossAversionRandom <- 0
## within-subject noise
noiseSd <- 0
ls()
buildSubjectProfile <- function() {
## Returns a vector with values to be added to / subtracted from fixed effects for each subject
subjectProfile <- c(subjectIntercept = rnorm(1, 0, interceptRandom), subjectExponents = rnorm(1, 0, exponentsRandom), subjectLossAversion = rnorm(1, 0, lossAversionRandom))
return(subjectProfile)
}
valueFunction <- function(criticalDeckIntensity, bias, subjectProfile) {
## The coding on the line below is such that harder critical decks are to the right on the x-axis
## Which puts the function in the correct direction if the DV is selection of reference deck
relativeIntensity <- criticalDeckIntensity - 0.5
## Adjust the value function parameters by bias and random effects
## These are essentially the level 2 equations
exponentsFinal <- min(max(exponentsFixed * convertBias(bias, exponentsFixed) + subjectProfile['subjectExponents'],0),1)
## constained so no one can have reverse loss aversion
lossAversionFinal <- max(lossAversionFixed * convertBias(bias, lossAversionFixed) + subjectProfile['subjectLossAversion'], 1)
## compute value
## flipping the x-axis also means that loss aversion needs to be reversed
out <- ifelse(relativeIntensity < 0, -(-relativeIntensity)^exponentsFinal, lossAversionFinal * (relativeIntensity) ^ exponentsFinal)
return(out)
}
decision <- function(criticalDeckIntensity, bias, trial, trialMax, subjectProfile) {
## takes as input all this stuff above
## returns the probability of choosing the reference deck
## Level 1 equation
proba <- subjectProfile['subjectIntercept'] + valueFunction(criticalDeckIntensity, bias, subjectProfile) * (trial / trialMax) + rnorm(1, 0, noiseSd)
proba <- exp(proba) / (1 + exp(proba))
return(proba)
}
d$y <- decision(d$x + 0.5, 1,1,1,subjectProfile)
plot(d$x, d$y)
q()
